{"version":3,"file":"effector.umd.js","sources":["../../src/effector/createNode.ts","../../src/effector/naming.ts","../../src/effector/collection.ts","../../src/effector/region.ts","../../src/effector/createUnit.ts","../../src/effector/combine.ts","../../src/effector/defer.ts","../../src/effector/createEffect.ts","../../src/effector/sample.ts","../../src/effector/fork.ts","../../src/effector/observable.ts","../../src/effector/tag.ts","../../src/effector/validate.ts","../../src/effector/throw.ts","../../src/effector/is.ts","../../src/effector/id.ts","../../src/effector/bind.ts","../../src/effector/step.ts","../../src/effector/stateRef.ts","../../src/effector/caller.ts","../../src/effector/getter.ts","../../src/effector/own.ts","../../src/effector/kernel.ts","../../src/effector/config.ts","../../src/effector/clearNode.ts","../../src/effector/subscription.ts","../../src/effector/forward.ts","../../src/effector/watch.ts","../../src/effector/createDomain.ts","../../src/effector/attach.ts","../../src/effector/createApi.ts","../../src/effector/fromObservable.ts","../../src/effector/guard.ts","../../src/effector/merge.ts","../../src/effector/restore.ts","../../src/effector/split.ts"],"sourcesContent":["import {Graph, Graphite, Cmd, StateRef} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\nimport {nextNodeID} from './id'\nimport {CROSSLINK, STORE} from './tag'\n\nconst arrifyNodes = (list: Graphite | Graphite[] = []): Graph[] => {\n  const result = []\n  if (Array.isArray(list)) {\n    for (let i = 0; i < list.length; i++) {\n      if (Array.isArray(list[i])) result.push(...(list[i] as any))\n      else result.push(list[i])\n    }\n  } else {\n    result.push(list)\n  }\n  return result.map(getGraph)\n}\nexport const addToReg = (\n  {hasRef, type, data}: any,\n  reg: Record<string, StateRef>,\n) => {\n  let store\n  if (hasRef) {\n    store = data.store\n    reg[store.id] = store\n  }\n  if (type === 'mov' && data.to === STORE) {\n    store = data.target\n    reg[store.id] = store\n  }\n}\nexport function createNode({\n  node = [],\n  from,\n  source,\n  parent = from || source,\n  to,\n  target,\n  child = to || target,\n  scope = {},\n  meta = {},\n  family: familyRaw = {type: 'regular'},\n}: {\n  node?: Array<Cmd | false | void | null>\n  from?: Graphite | Graphite[]\n  source?: Graphite | Graphite[]\n  parent?: Graphite | Graphite[]\n  to?: Graphite | Graphite[]\n  target?: Graphite | Graphite[]\n  child?: Graphite | Graphite[]\n  scope?: {[name: string]: any}\n  meta?: {[name: string]: any}\n  family?: {\n    type?: 'regular' | 'crosslink' | 'domain'\n    links?: Graphite | Graphite[]\n    owners?: Graphite | Graphite[]\n  }\n} = {}): Graph {\n  const sources = arrifyNodes(parent)\n  const links = arrifyNodes(familyRaw.links)\n  const owners = arrifyNodes(familyRaw.owners)\n  const seq: Cmd[] = []\n  const reg: {[id: string]: StateRef} = {}\n  for (let i = 0; i < node.length; i++) {\n    const item = node[i]\n    if (!item) continue\n    seq.push(item)\n    addToReg(item, reg)\n  }\n  const result: Graph = {\n    id: nextNodeID(),\n    seq,\n    next: arrifyNodes(child),\n    meta,\n    scope,\n    family: {\n      type: familyRaw.type || CROSSLINK,\n      links,\n      owners,\n    },\n    reg,\n  }\n  for (let i = 0; i < links.length; i++) {\n    getOwners(links[i]).push(result)\n  }\n  for (let i = 0; i < owners.length; i++) {\n    getLinks(owners[i]).push(result)\n  }\n  for (let i = 0; i < sources.length; i++) {\n    sources[i].next.push(result)\n  }\n  return result\n}\n","import {Store, Domain} from './unit.h'\nimport {is} from './is'\nimport {getParent} from './getter'\n\nexport const joinName = (unit: any, tag: string) => '' + unit.shortName + tag\n\nexport const mapName = (unit: any, name?: string) =>\n  name == null ? joinName(unit, ' → *') : name\n\nexport function unitObjectName(objOrArr: any, method: string = 'combine') {\n  let name = method + '('\n  let comma = ''\n  let i = 0\n  //@ts-ignore\n  for (const key in objOrArr) {\n    //@ts-ignore\n    const unit = objOrArr[key]\n    if (unit != null) {\n      name += comma\n      //@ts-ignore\n      name += is.unit(unit) ? unit.compositeName.fullName : unit.toString()\n    }\n    i += 1\n    /* inlined max object names constant */\n    if (i === 25) break\n    comma = ', '\n  }\n  name += ')'\n  return name\n}\n\nexport function setStoreName<State>(store: Store<State>, rawName: string) {\n  const compositeName = createName(rawName, getParent(store))\n  store.shortName = rawName\n  if (!store.compositeName) {\n    store.compositeName = compositeName\n    return\n  }\n  const currentComposite = store.compositeName\n  currentComposite.path = compositeName.path\n  currentComposite.shortName = compositeName.shortName\n  currentComposite.fullName = compositeName.fullName\n}\n\nexport type CompositeName = {\n  shortName: string\n  fullName: string\n  path: string[]\n}\n\nexport function createName(name: string, parent?: Domain): CompositeName {\n  let path: string[]\n  let fullName\n  let composite\n  const shortName = name\n  if (!parent) {\n    if (name.length === 0) {\n      path = []\n    } else {\n      path = [name]\n    }\n    fullName = name\n  } else {\n    composite = parent.compositeName\n    if (name.length === 0) {\n      path = composite.path\n      fullName = composite.fullName\n    } else {\n      path = composite.path.concat([name])\n      if (composite.fullName.length === 0) {\n        fullName = name\n      } else {\n        fullName = '' + composite.fullName + '/' + name\n      }\n    }\n  }\n  return {shortName, fullName, path}\n}\n","export const forIn = (obj: any, cb: (value: any, key: string) => void) => {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n\nexport const includes = (list: any[], item: any) => list.includes(item)\n\nexport const removeItem = (list: any[], item: any) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\n\nexport function forEach<T>(\n  list: T[],\n  fn: (item: T, index: number, list: T[]) => void,\n): void\nexport function forEach<T>(list: Set<T>, fn: (item: T) => void): void\nexport function forEach(list: any, fn: Function) {\n  list.forEach(fn)\n}\n","import {getValue, getGraph, getParent} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\n\ntype RegionStack = {\n  parent: RegionStack | null\n  value: any\n  template: any\n  sidRoot?: string\n}\n\nexport const addToRegion = (unit: any) => {\n  if (regionStack) own(getValue(regionStack), [unit])\n  return unit\n}\n\nlet regionStack: RegionStack | null = null\n\nexport const readTemplate = () => regionStack && regionStack.template\nexport const readSidRoot = (sid?: string | null) => {\n  if (sid && regionStack && regionStack.sidRoot)\n    sid = `${regionStack.sidRoot}ɔ${sid}`\n  return sid\n}\n\nexport function withRegion(unit: any, cb: () => void) {\n  const unitMeta = getGraph(unit).meta\n  regionStack = {\n    parent: regionStack,\n    value: unit,\n    template: unitMeta.template || readTemplate(),\n    sidRoot: unitMeta.sidRoot || (regionStack && regionStack.sidRoot),\n  }\n  try {\n    return cb()\n  } finally {\n    regionStack = getParent(regionStack)\n  }\n}\n\nexport const withFactory = ({\n  sid,\n  name,\n  loc,\n  method,\n  fn,\n}: {\n  sid: string\n  name?: string\n  loc?: any\n  method?: string\n  fn: () => any\n}) => {\n  const sidNode = createNode({\n    meta: {\n      sidRoot: readSidRoot(sid),\n      name,\n      loc,\n      method,\n    },\n  })\n  return withRegion(sidNode, fn)\n}\n","import {observableSymbol} from './observable'\n\nimport {is, isObject, isFunction, assertObject} from './is'\nimport {Store, Event} from './unit.h'\n\nimport {step} from './typedef'\nimport {createStateRef, readRef} from './stateRef'\nimport {nextUnitID} from './id'\nimport {callStackAReg, callARegStack, callStack} from './caller'\nimport {bind} from './bind'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, currentPage, forkPage, setCurrentPage} from './kernel'\n\nimport {Subscriber, Config} from './index.h'\nimport {createName, mapName, joinName} from './naming'\nimport {createLinkNode} from './forward'\nimport {watchUnit} from './watch'\nimport {createSubscription} from './subscription'\nimport {addToRegion, readTemplate, readSidRoot} from './region'\nimport {\n  getSubscribers,\n  getConfig,\n  getNestedConfig,\n  getStoreState,\n  getGraph,\n  getParent,\n} from './getter'\nimport {includes} from './collection'\nimport {throwError} from './throw'\nimport {DOMAIN, STORE, EVENT, MAP, FILTER, REG_A} from './tag'\n\nconst normalizeConfig = (part: any, config: any) => {\n  if (isObject(part)) {\n    normalizeConfig(getConfig(part), config)\n    if (part.name != null) {\n      if (isObject(part.name)) normalizeConfig(part.name, config)\n      else if (isFunction(part.name)) config.handler = part.name\n      else config.name = part.name\n    }\n    if (part.loc) config.loc = part.loc\n    if (part.sid || part.sid === null) config.sid = part.sid\n    if (part.handler) config.handler = part.handler\n    if (getParent(part)) config.parent = getParent(part)\n    if ('strict' in part) config.strict = part.strict\n    if (part.named) config.named = part.named\n    normalizeConfig(getNestedConfig(part), config)\n  }\n  return config\n}\n\nexport const applyParentHook = (\n  source: any,\n  target: any,\n  hookType: 'event' | 'effect' = EVENT,\n) => {\n  if (getParent(source)) getParent(source).hooks[hookType](target)\n}\n\nlet isStrict: boolean\nexport const initUnit = (\n  kind: any,\n  unit: any,\n  rawConfigA: any,\n  rawConfigB?: any,\n) => {\n  const config = normalizeConfig(\n    {\n      name: rawConfigB,\n      config: rawConfigA,\n    },\n    {},\n  )\n  const isDomain = kind === DOMAIN\n  const id = nextUnitID()\n  let {parent = null, sid = null, strict = true, named = null} = config\n  const name = named ? named : config.name || (isDomain ? '' : id)\n  const compositeName = createName(name, parent)\n\n  const meta: Record<string, any> = {\n    unit: unit.kind = kind,\n    name: unit.shortName = name,\n    sid: unit.sid = readSidRoot(sid),\n    named,\n    unitId: unit.id = id,\n  }\n  unit.parent = parent\n  unit.compositeName = compositeName\n  unit.defaultConfig = config\n  unit.thru = (fn: Function) => fn(unit)\n  unit.getType = () => compositeName.fullName\n  if (!isDomain) {\n    unit.subscribe = (observer: Subscriber<any>) => {\n      assertObject(observer)\n      return unit.watch(\n        isFunction(observer)\n          ? observer\n          : (upd: any) => {\n              if (observer.next) {\n                observer.next(upd)\n              }\n            },\n      )\n    }\n    unit[observableSymbol] = () => unit\n    const template = readTemplate()\n    if (template) meta.nativeTemplate = template\n  }\n  isStrict = strict\n  return meta\n}\nexport const createNamedEvent = (named: string) => createEvent({named})\n\nconst createComputation = (from: any, to: any, op: any, fn: Function) =>\n  createLinkNode(from, to, {\n    scope: {fn},\n    node: [step.compute({fn: callStack})],\n    meta: {op},\n  })\n\nconst createEventFiltration = (event: any, op: string, fn: any, node: any) => {\n  let config\n  if (isObject(fn)) {\n    config = fn\n    fn = fn.fn\n  }\n  const mapped = createEvent(joinName(event, ' →? *'), config)\n  createLinkNode(event, mapped, {\n    scope: {fn},\n    node,\n    meta: {op},\n  })\n  return mapped\n}\n\nfunction callCreate(unit: any, template: any, payload: any, args: any[]): any {\n  const oldPage = currentPage\n  let page = null\n  if (template) {\n    page = currentPage\n    while (page && page.template !== template) {\n      page = getParent(page)\n    }\n  }\n  setCurrentPage(page)\n  const result = unit.create(payload, args)\n  setCurrentPage(oldPage)\n  return result\n}\n\nexport function createEvent<Payload = any>(\n  nameOrConfig?: any,\n  maybeConfig?: any,\n): Event<Payload> {\n  const event: any = (payload: Payload, ...args: any[]) => {\n    if (currentPage) {\n      return callCreate(event, template, payload, args)\n    }\n    return event.create(payload, args)\n  }\n  event.graphite = createNode({\n    meta: initUnit(EVENT, event, maybeConfig, nameOrConfig),\n  })\n  //eslint-disable-next-line no-unused-vars\n  event.create = (payload: any, _: any) => {\n    const target = forkPage ? forkPage.find(event) : event\n    launch(target, payload)\n    return payload\n  }\n  event.watch = bind(watchUnit, event)\n  event.map = (fn: any) => {\n    let config\n    let name\n    if (isObject(fn)) {\n      config = fn\n      name = fn.name\n      fn = fn.fn\n    }\n    const mapped = createEvent(mapName(event, name), config)\n    createComputation(event, mapped, MAP, fn)\n    return mapped\n  }\n  event.filter = (fn: any) =>\n    createEventFiltration(event, FILTER, fn.fn ? fn : fn.fn, [\n      step.filter({fn: callStack}),\n    ])\n  event.filterMap = (fn: any) =>\n    createEventFiltration(event, 'filterMap', fn, [\n      step.compute({fn: callStack}),\n      step.check.defined(),\n    ])\n  event.prepend = (fn: any) => {\n    const contramapped: Event<any> = createEvent('* → ' + event.shortName, {\n      parent: getParent(event),\n    })\n    const template = readTemplate()\n    if (template) {\n      getGraph(contramapped).seq.push(template.upward)\n    }\n    createComputation(contramapped, event, 'prepend', fn)\n    applyParentHook(event, contramapped)\n    return contramapped\n  }\n  const template = readTemplate()\n  return addToRegion(event)\n}\n\nexport function createStore<State>(\n  defaultState: State,\n  props?: Config,\n): Store<State> {\n  const plainState = createStateRef(defaultState)\n  const oldState = createStateRef(defaultState)\n  const updates = createNamedEvent('updates')\n  const template = readTemplate()\n  plainState.after = [{type: 'copy', to: oldState}]\n  if (template) {\n    template.plain.push(plainState, oldState)\n  }\n  const plainStateId = plainState.id\n  const store: any = {\n    subscribers: new Map(),\n    updates,\n    defaultState,\n    stateRef: plainState,\n    getState() {\n      let targetRef = plainState\n      let reachedPage\n      if (currentPage) {\n        let page = currentPage\n        while (page && !page.reg[plainStateId]) {\n          page = getParent(page)\n        }\n        if (page) reachedPage = page\n      }\n      if (!reachedPage && forkPage && forkPage.reg[plainStateId]) {\n        reachedPage = forkPage\n      }\n      if (reachedPage) targetRef = reachedPage.reg[plainStateId]\n      return readRef(targetRef)\n    },\n    setState(state: any) {\n      let target\n      if (forkPage) {\n        target = forkPage.nodeMap[getGraph(store).id]\n      }\n      if (!target) target = store\n      launch({\n        target,\n        params: state,\n        defer: true,\n      })\n    },\n    reset(...units: any[]) {\n      for (const unit of units) store.on(unit, () => store.defaultState)\n      return store\n    },\n    on(events: any, fn: Function) {\n      if (Array.isArray(events)) {\n        for (const event of events) {\n          onEvent(event, fn)\n        }\n      } else {\n        onEvent(events, fn)\n      }\n      return store\n    },\n    off(unit: any) {\n      const currentSubscription = getSubscribers(store).get(unit)\n      if (currentSubscription) {\n        currentSubscription()\n        getSubscribers(store).delete(unit)\n      }\n      return store\n    },\n    map(fn: any, firstState?: any) {\n      let config\n      let name\n      if (isObject(fn)) {\n        config = fn\n        name = fn.name\n        firstState = fn.firstState\n        fn = fn.fn\n      }\n      let lastResult\n      const storeState = store.getState()\n      const template = readTemplate()\n      if (template) {\n        lastResult = null\n      } else if (storeState !== undefined) {\n        lastResult = fn(storeState, firstState)\n      }\n\n      const innerStore: Store<any> = createStore(lastResult, {\n        name: mapName(store, name),\n        config,\n        strict: false,\n      })\n      const linkNode = updateStore(store, innerStore, MAP, false, fn)\n\n      getStoreState(innerStore).before = [\n        {\n          type: MAP,\n          fn,\n          from: plainState,\n        },\n      ]\n      if (template) {\n        if (!includes(template.plain, plainState)) {\n          if (!includes(linkNode.seq, template.loader)) {\n            linkNode.seq.unshift(template.loader)\n          }\n        }\n      }\n      return innerStore\n    },\n    watch(eventOrFn: any, fn?: Function) {\n      if (!fn || !is.unit(eventOrFn)) {\n        const subscription = watchUnit(store, eventOrFn)\n        const template = readTemplate()\n        if (template) {\n          template.watch.push({\n            of: plainState,\n            fn: eventOrFn,\n          })\n        } else {\n          eventOrFn(store.getState())\n        }\n        return subscription\n      }\n      if (!isFunction(fn)) throwError('second argument should be a function')\n      return eventOrFn.watch((payload: any) => fn(store.getState(), payload))\n    },\n  }\n  function onEvent(event: any, fn: Function) {\n    store.off(event)\n    getSubscribers(store).set(\n      event,\n      createSubscription(updateStore(event, store, 'on', true, fn)),\n    )\n  }\n  store.graphite = createNode({\n    scope: {state: plainState},\n    node: [\n      step.check.defined(),\n      step.update({\n        store: plainState,\n      }),\n      step.check.changed({\n        store: oldState,\n      }),\n      step.update({\n        store: oldState,\n      }),\n    ],\n    child: updates,\n    meta: initUnit(STORE, store, props),\n  })\n  if (isStrict && defaultState === undefined)\n    throwError(\"current state can't be undefined, use null instead\")\n  own(store, [updates])\n  return addToRegion(store)\n}\n\nconst updateStore = (\n  from: any,\n  store: Store<any>,\n  op: string,\n  stateFirst: boolean,\n  fn: Function,\n) => {\n  const storeRef = getStoreState(store)\n  const node = [\n    step.mov({store: storeRef, to: REG_A}),\n    step.compute({\n      fn: stateFirst ? callARegStack : callStackAReg,\n    }),\n    step.check.defined(),\n    step.check.changed({store: storeRef}),\n    step.update({store: storeRef}),\n  ]\n  const template = readTemplate()\n  if (template) {\n    node.unshift(template.loader)\n    node.push(template.upward)\n    if (is.store(from)) {\n      const ref = getStoreState(from)\n      if (!includes(template.plain, ref)) {\n        //if (!includes(node, template.loader)) {\n        //  node.unshift(template.loader)\n        //}\n        if (!includes(template.closure, ref)) {\n          template.closure.push(ref)\n        }\n        if (!storeRef.before) storeRef.before = []\n        storeRef.before.push({\n          type: 'closure',\n          of: ref,\n        })\n      }\n    } else {\n      //if (!includes(node, template.loader)) {\n      //  node.unshift(template.loader)\n      //}\n    }\n  }\n  return createLinkNode(from, store, {\n    scope: {fn},\n    node,\n    meta: {op},\n  })\n}\n","import {Store} from './unit.h'\nimport {createStore} from './createUnit'\nimport {createStateRef} from './stateRef'\nimport {step} from './typedef'\nimport {onConfigNesting} from './config'\nimport {getStoreState} from './getter'\nimport {is, isFunction, isObject} from './is'\nimport {unitObjectName} from './naming'\nimport {createLinkNode} from './forward'\nimport {throwError} from './throw'\nimport {readTemplate} from './region'\nimport {forIn, includes} from './collection'\nimport {BARRIER, MAP, REG_A, VALUE} from './tag'\n\nexport function combine(...args: any[]): Store<any> {\n  let handler\n  let stores\n  let config\n  onConfigNesting(args[0], (injectedData, userConfig) => {\n    config = injectedData\n    args = userConfig\n  })\n  const rawHandler = args[args.length - 1]\n  if (isFunction(rawHandler)) {\n    stores = args.slice(0, -1)\n    handler = rawHandler\n  } else {\n    stores = args\n  }\n\n  let structStoreShape\n  let shapeReady\n  if (stores.length === 1) {\n    const obj = stores[0]\n    /*\n      without edge case combine(Color, (Color) => '~')\n      */\n    if (!is.store(obj)) {\n      /*\n      case combine([R,G,B], ([R,G,B]) => '~')\n      case combine({R,G,B}, ({R,G,B}) => '~')\n\n      edge case combine([Color], ([Color]) => '~')\n      edge case combine({Color}, ({Color}) => '~')\n\n      edge case combine([R,G,B])\n      edge case combine({R,G,B})\n\n      edge case combine([Color])\n      edge case combine({Color})\n      */\n      structStoreShape = obj\n      shapeReady = true\n    }\n  }\n  if (!shapeReady) {\n    /*\n    case combine(R,G,B, (R,G,B) => '~')\n    */\n    structStoreShape = stores\n    /*\n    without edge case combine(R,G,B)\n    without edge case combine(Color)\n    */\n    if (handler) {\n      handler = spreadArgs(handler)\n    }\n  }\n  if (!isObject(structStoreShape)) throwError('shape should be an object')\n  return storeCombination(\n    Array.isArray(structStoreShape),\n    structStoreShape,\n    config,\n    handler,\n  )\n}\n\nconst spreadArgs = (fn: Function) => (list: any[]) => fn(...list)\n\nconst storeCombination = (\n  isArray: boolean,\n  obj: any,\n  config?: string,\n  fn?: (upd: any) => any,\n) => {\n  const clone = isArray ? (list: any) => list.slice() : (obj: any) => ({...obj})\n  const defaultState: any = isArray ? [] : {}\n  const template = readTemplate()\n  const stateNew = clone(defaultState)\n  const rawShape = createStateRef(stateNew)\n  const isFresh = createStateRef(true)\n  rawShape.type = isArray ? 'list' : 'shape'\n  if (template) {\n    template.plain.push(rawShape, isFresh)\n  }\n  const store = createStore(stateNew, {\n    name: config ? config : unitObjectName(obj),\n  })\n  const node = [\n    step.check.defined(),\n    step.mov({\n      store: rawShape,\n      to: REG_A,\n    }),\n    //prettier-ignore\n    step.filter({\n      fn: (upd, {key}, {a}) => upd !== a[key],\n    }),\n    step.mov({\n      store: isFresh,\n      to: 'b',\n    }),\n    step.compute({\n      fn(upd, {clone, key}, reg) {\n        if (reg.b) {\n          reg.a = clone(reg.a)\n        }\n        reg.a[key] = upd\n      },\n    }),\n    step.mov({\n      from: REG_A,\n      target: rawShape,\n    }),\n    step.mov({\n      from: VALUE,\n      store: false,\n      target: isFresh,\n    }),\n    step.barrier({priority: BARRIER}),\n    step.mov({\n      from: VALUE,\n      store: true,\n      target: isFresh,\n    }),\n    step.mov({store: rawShape}),\n    fn && step.compute({fn}),\n    step.check.changed({\n      store: getStoreState(store),\n    }),\n  ]\n  const before: any[] = (rawShape.before = [])\n  forIn(obj, (child, key) => {\n    if (!is.store(child)) {\n      stateNew[key] = defaultState[key] = child\n      return\n    }\n    defaultState[key] = child.defaultState\n    stateNew[key] = child.getState()\n    const linkNode = createLinkNode(child, store, {\n      scope: {key, clone},\n      node,\n      meta: {op: 'combine'},\n    })\n    const childRef = getStoreState(child)\n    before.push({\n      type: 'field',\n      field: key,\n      from: childRef,\n    })\n    if (template) {\n      if (!includes(template.plain, childRef)) {\n        linkNode.seq.unshift(template.loader)\n      }\n    }\n  })\n\n  store.defaultShape = obj\n  rawShape.after = [\n    fn\n      ? {\n          type: MAP,\n          to: getStoreState(store),\n          fn,\n        }\n      : {\n          type: 'copy',\n          to: getStoreState(store),\n        },\n  ]\n  if (!template) {\n    store.defaultState = fn\n      ? (getStoreState(store).current = fn(stateNew))\n      : defaultState\n  }\n  return store\n}\n","export function createDefer(): {\n  rs: (value: any) => any\n  rj: (value: any) => any\n  req: Promise<any>\n} {\n  const result = {} as {\n    rs: (value: any) => any\n    rj: (value: any) => any\n    req: Promise<any>\n  }\n  result.req = new Promise((rs, rj) => {\n    result.rs = rs\n    result.rj = rj\n  })\n  result.req.catch(err => {})\n  return result\n}\n","import {step} from './typedef'\nimport {getForkPage, getGraph, getParent} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, setForkPage, forkPage, isWatch} from './kernel'\nimport {createNamedEvent, createStore, createEvent} from './createUnit'\nimport {createDefer} from './defer'\nimport {isObject, isFunction} from './is'\nimport {throwError} from './throw'\nimport {EFFECT} from './tag'\n\nexport function createEffect<Payload, Done>(\n  nameOrConfig: any,\n  maybeConfig: any,\n) {\n  const instance: any = createEvent(nameOrConfig, maybeConfig)\n  let handler =\n    instance.defaultConfig.handler ||\n    (() => throwError(`no handler used in ${instance.getType()}`))\n  const node = getGraph(instance)\n  node.meta.onCopy = ['runner']\n  node.meta.unit = instance.kind = EFFECT\n  instance.use = (fn: Function) => {\n    if (!isFunction(fn)) throwError('.use argument should be a function')\n    handler = fn\n    return instance\n  }\n  const anyway = (instance.finally = createNamedEvent('finally'))\n  const done = (instance.done = (anyway as any).filterMap({\n    named: 'done',\n    fn({status, params, result}: any) {\n      if (status === 'done') return {params, result}\n    },\n  }))\n  const fail = (instance.fail = (anyway as any).filterMap({\n    named: 'fail',\n    fn({status, params, error}: any) {\n      if (status === 'fail') return {params, error}\n    },\n  }))\n  const doneData = (instance.doneData = done.map({\n    named: 'doneData',\n    fn: ({result}: any) => result,\n  }))\n  const failData = (instance.failData = fail.map({\n    named: 'failData',\n    fn: ({error}: any) => error,\n  }))\n\n  const effectRunner = createNode({\n    scope: {\n      getHandler: instance.use.getCurrent = () => handler,\n      finally: anyway,\n    },\n    node: [\n      step.run({\n        fn({params, req}, {finally: anyway, getHandler}, stack) {\n          const onResolve = onSettled({\n            params,\n            req,\n            ok: true,\n            anyway,\n            stack,\n          })\n          const onReject = onSettled({\n            params,\n            req,\n            ok: false,\n            anyway,\n            stack,\n          })\n          let result\n          try {\n            result = getHandler()(params)\n          } catch (err) {\n            return void onReject(err)\n          }\n          if (isObject(result) && isFunction(result.then)) {\n            result.then(onResolve, onReject)\n          } else {\n            onResolve(result)\n          }\n        },\n      }),\n    ],\n    meta: {\n      op: 'fx',\n      fx: 'runner',\n      onCopy: ['finally'],\n    },\n  })\n  node.scope.runner = effectRunner\n  node.seq.push(\n    step.compute({\n      fn(params, scope, stack) {\n        // empty stack means that this node was launched directly\n        if (!getParent(stack)) return params\n        return {\n          params,\n          req: {\n            rs(data: any) {},\n            rj(data: any) {},\n          },\n        }\n      },\n    }),\n    step.run({\n      fn(upd, {runner}, stack) {\n        launch({\n          target: runner,\n          params: upd,\n          defer: true,\n          forkPage: getForkPage(stack),\n        })\n        return upd.params\n      },\n    }),\n  )\n  instance.create = (params: Payload) => {\n    const req = createDefer()\n    const payload = {params, req}\n    if (forkPage) {\n      if (!isWatch) {\n        const savedFork = forkPage\n        req.req.finally(() => {\n          setForkPage(savedFork)\n        })\n      }\n      launch(forkPage.find(instance), payload)\n    } else {\n      launch(instance, payload)\n    }\n    return req.req\n  }\n\n  const inFlight = (instance.inFlight = createStore(0, {named: 'inFlight'})\n    .on(instance, x => x + 1)\n    .on(anyway, x => x - 1))\n\n  const pending = (instance.pending = inFlight.map({\n    //@ts-ignore\n    fn: amount => amount > 0,\n    named: 'pending',\n  }))\n\n  own(instance, [\n    anyway,\n    done,\n    fail,\n    doneData,\n    failData,\n    pending,\n    inFlight,\n    effectRunner,\n  ])\n  return instance\n}\n\nexport const onSettled = ({\n  params,\n  req,\n  ok,\n  anyway,\n  stack,\n}: {\n  params: any\n  req: {\n    rs(_: any): any\n    rj(_: any): any\n  }\n  ok: boolean\n  anyway: any\n  stack: any\n}) => (data: any) =>\n  launch({\n    target: [anyway, sidechain],\n    params: [\n      ok\n        ? {\n            status: 'done',\n            params,\n            result: data,\n          }\n        : {\n            status: 'fail',\n            params,\n            error: data,\n          },\n      {\n        fn: ok ? req.rs : req.rj,\n        value: data,\n      },\n    ],\n    defer: true,\n    page: stack.page,\n    forkPage: getForkPage(stack),\n  })\n\nconst sidechain = createNode({\n  node: [\n    step.run({\n      fn({fn, value}) {\n        fn(value)\n      },\n    }),\n  ],\n  meta: {op: 'fx', fx: 'sidechain'},\n})\n","import {combine} from './combine'\nimport {step} from './typedef'\nimport {createStateRef, readRef} from './stateRef'\nimport {callStackAReg, callARegStack} from './caller'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, getGraph} from './getter'\nimport {own} from './own'\nimport {is} from './is'\nimport {createStore} from './createUnit'\nimport {createEvent} from './createUnit'\nimport {createLinkNode} from './forward'\nimport {createNode} from './createNode'\nimport {addToRegion, readTemplate} from './region'\nimport {throwError} from './throw'\nimport {includes} from './collection'\nimport {REG_A, SAMPLE, SAMPLER, STACK, STORE, VALUE} from './tag'\n\nexport function sample(...args: any): any {\n  let target\n  let name\n  let [[source, clock, fn], metadata] = processArgsToConfig(args)\n  let sid\n  let greedy\n  //config case\n  if (clock === undefined && 'source' in source) {\n    if ('clock' in source && source.clock == null)\n      throwError('config.clock should be defined')\n    clock = source.clock\n    fn = source.fn\n    greedy = source.greedy\n    //optional target & name accepted only from config\n    target = source.target\n    name = source.name\n    sid = source.sid\n    source = source.source\n  }\n  if (!is.unit(source)) {\n    source = combine(source)\n  }\n  if (clock === undefined) {\n    //still undefined!\n    clock = source\n  }\n  name = metadata || name || source.shortName\n  const template = readTemplate()\n  const isUpward = !!target\n  if (!target) {\n    if (is.store(source) && is.store(clock)) {\n      const initialState = fn\n        ? fn(readRef(getStoreState(source)), readRef(getStoreState(clock)))\n        : readRef(getStoreState(source))\n      target = createStore(initialState, {name, sid})\n    } else {\n      target = createEvent(name)\n      if (template) {\n        getGraph(target).seq.push(template.loader)\n      }\n    }\n  }\n  const targetTemplate =\n    isUpward && is.unit(target) && getGraph(target).meta.nativeTemplate\n  if (is.store(source)) {\n    const sourceRef = getStoreState(source)\n    own(source, [\n      createLinkNode(clock, target, {\n        scope: {fn, targetTemplate},\n        node: [\n          template && template.loader,\n          //@ts-ignore\n          !greedy && step.barrier({priority: SAMPLER}),\n          step.mov({\n            store: sourceRef,\n            to: fn ? REG_A : STACK,\n          }),\n          fn && step.compute({fn: callARegStack}),\n          template && isUpward && template.upward,\n        ],\n        meta: {op: SAMPLE, sample: STORE},\n      }),\n    ])\n    if (template) {\n      if (\n        !includes(template.plain, sourceRef) &&\n        !includes(template.closure, sourceRef)\n      ) {\n        template.closure.push(sourceRef)\n      }\n    }\n  } else {\n    const hasSource = createStateRef(false)\n    const sourceState = createStateRef()\n    const clockState = createStateRef()\n    if (template) {\n      template.plain.push(hasSource, sourceState, clockState)\n    }\n    addToRegion(\n      createNode({\n        parent: source,\n        node: [\n          step.update({store: sourceState}),\n          step.mov({\n            from: VALUE,\n            store: true,\n            target: hasSource,\n          }),\n        ],\n        family: {\n          owners: [source, target, clock],\n          links: target,\n        },\n        meta: {op: SAMPLE, sample: 'source'},\n      }),\n    )\n    own(source, [\n      createLinkNode(clock, target, {\n        scope: {\n          fn,\n          targetTemplate,\n        },\n        node: [\n          template && template.loader,\n          step.update({store: clockState}),\n          step.mov({store: hasSource}),\n          step.filter({fn: hasSource => hasSource}),\n          //@ts-ignore\n          !greedy && step.barrier({priority: SAMPLER}),\n          step.mov({store: sourceState}),\n          step.mov({\n            store: clockState,\n            to: REG_A,\n          }),\n          fn && step.compute({fn: callStackAReg}),\n          template && isUpward && template.upward,\n        ],\n        meta: {op: SAMPLE, sample: 'clock'},\n      }),\n    ])\n  }\n  return target\n}\n","import {getForkPage, getGraph, getLinks, getOwners} from './getter'\nimport {bind} from './bind'\nimport {createDefer} from './defer'\nimport {watchUnit} from './watch'\nimport {is, isObject} from './is'\nimport {throwError} from './throw'\nimport {launch, forkPage, setForkPage} from './kernel'\nimport {createNode} from './createNode'\nimport {step} from './typedef'\nimport {Domain, Store} from './unit.h'\nimport {Graph, StateRef} from './index.h'\nimport {removeItem, forEach, includes, forIn} from './collection'\nimport {DOMAIN, STORE, EVENT, EFFECT, SAMPLER, MAP, FORK_COUNTER} from './tag'\n\n/**\nhydrate state on client\n\nconst root = createDomain()\nhydrate(root, {\n  values: window.__initialState__\n})\n\n*/\nexport function hydrate(domain: Domain, {values}: {values: any}) {\n  const isScope = isObject(domain) && (domain as any).cloneOf\n  if (!is.domain(domain) && !isScope) {\n    throwError('first argument of hydrate should be domain or scope')\n  }\n  if (!isObject(values)) {\n    throwError('values property should be an object')\n  }\n  const normalizedValues = normalizeValues(values)\n  let storeWatches: Graph[]\n  let storeWatchesRefs: any[]\n  if (isScope) {\n    storeWatches = []\n    storeWatchesRefs = []\n    forIn(normalizedValues, (val, sid) => {\n      //@ts-ignore\n      const node = domain.sidMap[sid]\n      if (node) {\n        storeWatches.push(node)\n        storeWatchesRefs.push(val)\n      }\n    })\n  } else {\n    const fillResult = fillValues({\n      flatGraphUnits: flatGraph(domain),\n      values: normalizedValues,\n      collectWatches: true,\n    })\n    storeWatches = fillResult.storeWatches\n    storeWatchesRefs = fillResult.storeWatchesRefs.map(({current}) => current)\n  }\n\n  launch({\n    target: storeWatches,\n    params: storeWatchesRefs,\n    forkPage: isScope ? domain : false,\n  })\n}\n\nfunction fillValues({\n  flatGraphUnits,\n  values,\n  collectWatches,\n}: {\n  flatGraphUnits: Graph[]\n  values: Record<string, any>\n  collectWatches: boolean\n}) {\n  const storeWatches = []\n  const storeWatchesRefs = []\n  const refsMap = {} as Record<string, StateRef>\n  const predefinedRefs = new Set()\n  const valuesSidList = Object.getOwnPropertyNames(values)\n  for (const node of flatGraphUnits) {\n    const {reg} = node\n    const {op, unit, sid} = node.meta\n    if (unit === STORE) {\n      if (sid && includes(valuesSidList, sid)) {\n        const {state} = node.scope\n        state.current = values[sid]\n        predefinedRefs.add(state)\n      }\n    }\n    if (collectWatches && op === 'watch') {\n      const owner = node.family.owners[0]\n      if (owner.meta.unit === STORE) {\n        storeWatches.push(node)\n        storeWatchesRefs.push(owner.scope.state)\n      }\n    }\n    for (const id in reg) {\n      refsMap[id] = reg[id]\n    }\n  }\n  const refGraph = createRefGraph(refsMap)\n  const result = toposort(refGraph)\n  forEach(result, id => {\n    execRef(refsMap[id])\n  })\n\n  return {\n    storeWatches,\n    storeWatchesRefs,\n  }\n  function execRef(ref: StateRef) {\n    let isFresh = false\n    if (ref.before && !predefinedRefs.has(ref)) {\n      for (const cmd of ref.before) {\n        switch (cmd.type) {\n          case MAP: {\n            const from = cmd.from\n            ref.current = cmd.fn(from.current)\n            break\n          }\n          case 'field': {\n            const from = cmd.from\n            if (!isFresh) {\n              isFresh = true\n              if (Array.isArray(ref.current)) {\n                ref.current = [...ref.current]\n              } else {\n                ref.current = {...ref.current}\n              }\n            }\n            ref.current[cmd.field] = from.current\n            break\n          }\n          case 'closure':\n            break\n        }\n      }\n    }\n    if (!ref.after) return\n    const value = ref.current\n    for (const cmd of ref.after) {\n      const to = cmd.to\n      // if (predefinedRefs.has(to)) continue\n      switch (cmd.type) {\n        case 'copy':\n          to.current = value\n          break\n        case MAP:\n          to.current = cmd.fn(value)\n          break\n      }\n    }\n  }\n}\n\nfunction createRefGraph(refsMap: Record<string, StateRef>) {\n  const items = Object.values(refsMap)\n  const refGraph = {} as Record<string, string[]>\n  for (const {id} of items) {\n    refGraph[id] = []\n  }\n  //prettier-ignore\n  for (const {id, before, after} of items) {\n    before && forEach(before, cmd => {\n      refGraph[cmd.from.id].push(id)\n    })\n    after && forEach(after, cmd => {\n      refGraph[id].push(cmd.to.id)\n    })\n  }\n  return refGraph\n}\n\n/**\nserialize state on server\n*/\nexport function serialize(\n  {clones, getState, cloneOf}: any,\n  {\n    ignore = [],\n    onlyChanges,\n  }: {ignore?: Array<Store<any>>; onlyChanges?: boolean} = {},\n) {\n  const result = {} as Record<string, any>\n  if (onlyChanges) {\n    ignore = [...ignore]\n    for (const store of cloneOf.history.stores) {\n      if (getState(store) === store.defaultState) {\n        ignore.push(store)\n      }\n    }\n  }\n  for (const {meta, scope, reg} of clones) {\n    if (meta.unit !== STORE) continue\n    const {sid} = meta\n    if (!sid) continue\n    result[sid] = reg[scope.state.id].current\n  }\n  for (const {sid} of ignore) {\n    if (sid) delete result[sid]\n  }\n  return result\n}\n\n/** bind event to scope */\nexport function scopeBind(unit: any) {\n  if (!forkPage) {\n    throwError('scopeBind cannot be called outside of forked .watch')\n  }\n  const result = forkPage.find(unit)\n  const savedStack = forkPage\n  return (payload: any) => {\n    launch({\n      target: result,\n      params: payload,\n      forkPage: savedStack,\n    })\n  }\n}\n\nfunction normalizeValues(values: Map<Store<any>, any> | Record<string, any>) {\n  if (values instanceof Map) {\n    const result = {} as Record<string, any>\n    for (const [key, value] of values) {\n      if (!is.unit(key)) throwError('Map key should be a unit')\n      result[key.sid!] = value\n    }\n    return result\n  }\n  return values\n}\nexport function fork(\n  domain: Domain,\n  {values, handlers}: {values?: any; handlers?: any} = {},\n) {\n  if (!is.domain(domain)) throwError('first argument of fork should be domain')\n  const needToFill = !!values\n  values = normalizeValues(values || {})\n  const forked = cloneGraph(domain)\n  if (needToFill) {\n    fillValues()\n  }\n  if (handlers) {\n    handlers = normalizeValues(handlers)\n    const handlerKeys = Object.keys(handlers)\n    for (const {scope, meta} of forked.clones) {\n      if (meta.sid && includes(handlerKeys, meta.sid)) {\n        scope.runner.scope.getHandler = () => handlers[meta.sid]\n      }\n    }\n  }\n  return forked\n\n  function fillValues() {\n    const sourceList = flatGraph(domain)\n    const sourceRefsMap = {} as Record<string, StateRef>\n    const refsMap = {} as Record<string, StateRef>\n    const predefinedRefs = new Set()\n    const templateOwnedRefs = new Set<string>()\n    const valuesSidList = Object.getOwnPropertyNames(values)\n    for (const {reg, meta} of sourceList) {\n      const {nativeTemplate} = meta\n      for (const id in reg) {\n        sourceRefsMap[id] = reg[id]\n        if (nativeTemplate) {\n          templateOwnedRefs.add(id)\n        }\n      }\n    }\n    for (const node of forked.clones) {\n      const {reg} = node\n      const {unit, sid} = node.meta\n      if (unit === STORE) {\n        if (sid && includes(valuesSidList, sid)) {\n          const {state} = node.scope\n          reg[state.id].current = values[sid]\n          predefinedRefs.add(state)\n        }\n      }\n      for (const id in reg) {\n        refsMap[id] = reg[id]\n      }\n    }\n    const refGraph = createRefGraph(sourceRefsMap)\n    const result = toposort(refGraph, templateOwnedRefs)\n    forEach(result, id => {\n      execRef(refsMap[id], sourceRefsMap[id])\n    })\n\n    function execRef(ref: StateRef, sourceRef?: StateRef) {\n      let isFresh = false\n      if (sourceRef && sourceRef.before && !predefinedRefs.has(ref)) {\n        for (const cmd of sourceRef.before) {\n          switch (cmd.type) {\n            case MAP: {\n              const from = refsMap[cmd.from.id]\n              ref.current = cmd.fn(from.current)\n              break\n            }\n            case 'field': {\n              const from = refsMap[cmd.from.id]\n              if (!isFresh) {\n                isFresh = true\n                if (Array.isArray(ref.current)) {\n                  ref.current = [...ref.current]\n                } else {\n                  ref.current = {...ref.current}\n                }\n              }\n              ref.current[cmd.field] = from.current\n              break\n            }\n            case 'closure':\n              break\n          }\n        }\n      }\n      if (!sourceRef || !sourceRef.after) return\n      const value = ref.current\n      for (const cmd of sourceRef.after) {\n        const to = refsMap[cmd.to.id]\n        // if (predefinedRefs.has(to)) continue\n        switch (cmd.type) {\n          case 'copy':\n            to.current = value\n            break\n          case MAP:\n            to.current = cmd.fn(value)\n            break\n        }\n      }\n    }\n  }\n}\nfunction toposort(rawGraph: Record<string, string[]>, ignore?: Set<string>) {\n  const graph = {} as Record<string, string[]>\n  for (const id in rawGraph) {\n    graph[id] = [...new Set(rawGraph[id])]\n  }\n  const result = [] as string[]\n  const visited = {} as Record<string, boolean>\n  const temp = {} as Record<string, boolean>\n  for (const node in graph) {\n    if (!visited[node] && !temp[node]) {\n      topologicalSortHelper(node)\n    }\n  }\n  result.reverse()\n  if (ignore && ignore.size > 0) {\n    const processed = [] as string[]\n    const ignored = [...ignore]\n    let item: string | void\n    while ((item = ignored.shift())) {\n      processed.push(item)\n      forEach(graph[item], child => {\n        if (includes(processed, child) || includes(ignored, child)) return\n        ignored.push(child)\n      })\n    }\n    forEach(processed, item => {\n      removeItem(result, item)\n    })\n  }\n  return result\n  function topologicalSortHelper(node: string) {\n    temp[node] = true\n    const neighbors = graph[node]\n    for (let i = 0; i < neighbors.length; i++) {\n      const n = neighbors[i]\n      if (temp[n]) {\n        continue\n        // throw Error('found cycle in DAG')\n      }\n      if (!visited[n]) {\n        topologicalSortHelper(n)\n      }\n    }\n    temp[node] = false\n    visited[node] = true\n    result.push(node)\n  }\n}\nexport function allSettled(\n  start: any,\n  {scope, params: ctx}: {scope: any; params?: any},\n) {\n  if (!is.unit(start))\n    return Promise.reject(Error('first argument should be unit'))\n  const defer = createDefer()\n  //@ts-ignore\n  defer.parentFork = forkPage\n  const {forkInFlightCounter} = scope.graphite.scope\n  forkInFlightCounter.scope.defers.push(defer)\n  const contextStart = scope.find(start)\n\n  const launchUnits = [contextStart]\n  const launchParams = []\n  if (is.effect(start)) {\n    launchParams.push({\n      params: ctx,\n      req: {\n        rs(value: any) {\n          //@ts-ignore\n          defer.value = {status: 'done', value}\n        },\n        rj(value: any) {\n          //@ts-ignore\n          defer.value = {status: 'fail', value}\n        },\n      },\n    })\n  } else {\n    launchParams.push(ctx)\n  }\n  launchUnits.push(forkInFlightCounter)\n  launchParams.push(null)\n  launch({\n    target: launchUnits,\n    params: launchParams,\n    forkPage: scope,\n  })\n  return defer.req\n}\nfunction flatGraph(unit: any) {\n  const list = [] as Graph[]\n  ;(function traverse(node) {\n    if (includes(list, node)) return\n    list.push(node)\n    forEachRelatedNode(node, traverse)\n  })(getGraph(unit))\n  return list\n}\n/**\neverything we need to clone graph section\nreachable from given unit\n*/\nfunction cloneGraph(unit: any) {\n  const list = flatGraph(unit)\n  const refs = new Map()\n  const scope = {\n    defers: [],\n    inFlight: 0,\n    fxID: 0,\n  }\n  const forkPageSetter = step.compute({\n    fn(data, _, stack) {\n      setForkPage(getForkPage(stack))\n      return data\n    },\n  })\n  const forkInFlightCounter = createNode({\n    scope,\n    node: [\n      step.compute({\n        fn(_, scope, stack) {\n          if (!stack.parent) {\n            scope.fxID += 1\n            return\n          }\n          if (stack.parent.node.meta.named === 'finally') {\n            scope.inFlight -= 1\n          } else {\n            scope.inFlight += 1\n            scope.fxID += 1\n          }\n        },\n      }),\n      step.barrier({priority: SAMPLER}),\n      step.run({\n        fn(_, scope) {\n          const {inFlight, defers, fxID} = scope\n          if (inFlight > 0 || defers.length === 0) return\n          Promise.resolve().then(() => {\n            if (scope.fxID !== fxID) return\n            forEach(defers.splice(0, defers.length), (defer: any) => {\n              setForkPage(defer.parentFork)\n              defer.rs(defer.value)\n            })\n          })\n        },\n      }),\n    ],\n    meta: {unit: FORK_COUNTER},\n  })\n  const nodeMap = {} as Record<string, Graph>\n  const sidMap = {} as Record<string, Graph>\n  const clones = list.map(node => {\n    const {seq, next, meta, scope} = node\n    const result = createNode({\n      node: seq.map(step => ({\n        id: step.id,\n        type: step.type,\n        data: {...step.data},\n        hasRef: step.hasRef,\n      })) as any,\n      child: [...next],\n      meta: {forkOf: node, ...meta},\n      scope: {...scope},\n    })\n    result.family = {\n      type: node.family.type,\n      links: [...getLinks(node)],\n      owners: [...getOwners(node)],\n    }\n    nodeMap[node.id] = result\n    if (meta.sid) sidMap[meta.sid] = result\n    return result\n  })\n  const page = {} as Record<string, StateRef>\n  forEach(clones, node => {\n    const {\n      reg,\n      scope,\n      meta: {onCopy, op, unit},\n    } = node\n    for (const id in reg) {\n      const ref = reg[id]\n      let newRef = refs.get(ref)\n      if (!newRef) {\n        newRef = {\n          id: ref.id,\n          current: ref.current, //ref.id in values ? values[ref.id] : ref.current,\n        }\n        refs.set(ref, newRef)\n      }\n      page[id] = reg[id] = newRef\n    }\n    if (onCopy) {\n      for (let j = 0; j < onCopy.length; j++) {\n        scope[onCopy[j]] = findClone(scope[onCopy[j]])\n      }\n    }\n    forEachRelatedNode(node, (node, i, siblings) => {\n      siblings[i] = findClone(node)\n    })\n    const itemTag = op || unit\n    switch (itemTag) {\n      case STORE:\n        node.meta.wrapped = wrapStore(node)\n        break\n      case EVENT:\n        node.seq.unshift(forkPageSetter)\n        break\n      case EFFECT:\n        node.next.push(forkInFlightCounter)\n        node.seq.unshift(forkPageSetter)\n        break\n      case 'fx': {\n        scope.finally.next.push(forkInFlightCounter)\n        node.seq.unshift(forkPageSetter)\n        break\n      }\n      case 'watch':\n        node.seq.unshift(forkPageSetter)\n        break\n    }\n  })\n\n  return {\n    cloneOf: unit,\n    nodeMap,\n    sidMap,\n    clones,\n    find: findClone,\n    reg: page,\n    getState: (store: any) => findClone(store).meta.wrapped.getState(),\n    graphite: createNode({\n      family: {\n        type: DOMAIN,\n        links: [forkInFlightCounter, ...clones],\n      },\n      meta: {unit: 'fork'},\n      scope: {forkInFlightCounter},\n    }),\n  }\n  function findClone(unit: any) {\n    const node = getGraph(unit)\n    const index = list.indexOf(node)\n    if (index === -1) {\n      let unitName = 'unit'\n      if (unit !== node && unit.id !== unit.shortName) unitName = unit.shortName\n      throwError(`${unitName} not found in forked scope`)\n    }\n    return clones[index]\n  }\n}\n\nfunction wrapStore(node: Graph) {\n  return {\n    kind: STORE,\n    getState: () => node.reg[node.scope.state.id].current,\n    updates: {\n      watch: bind(watchUnit, node),\n    },\n    graphite: node,\n    family: node.family,\n  }\n}\nfunction forEachRelatedNode(\n  node: Graph,\n  cb: (node: Graph, index: number, siblings: Graph[]) => void,\n) {\n  const unit = node.meta.unit\n  if (unit === 'fork' || unit === FORK_COUNTER) return\n  forEach(node.next, cb)\n  forEach(getOwners(node), cb)\n  forEach(getLinks(node), cb)\n}\n","export const observableSymbol: any =\n  (typeof Symbol !== 'undefined' && Symbol.observable) || '@@observable'\n","export const STORE = 'store'\nexport const EVENT = 'event'\nexport const EFFECT = 'effect'\nexport const DOMAIN = 'domain'\nexport const SAMPLER = 'sampler'\nexport const CROSSLINK = 'crosslink'\nexport const MAP = 'map'\nexport const STACK = 'stack'\nexport const BARRIER = 'barrier'\nexport const VALUE = 'value'\nexport const FORK_COUNTER = 'forkInFlightCounter'\nexport const SAMPLE = 'sample'\nexport const FILTER = 'filter'\nexport const REG_A = 'a'\n","import {kind} from './index.h'\nimport {DOMAIN, STORE, EVENT, EFFECT} from './tag'\nimport {isObject, isFunction} from './is'\n\nexport const unit = (obj: any) =>\n  (isFunction(obj) || isObject(obj)) && 'kind' in obj\n\nconst is = (type: kind) => (obj: any) => unit(obj) && obj.kind === type\n\nexport const store = is(STORE)\nexport const event = is(EVENT)\nexport const effect = is(EFFECT)\nexport const domain = is(DOMAIN)\n","export const throwError = (message: string) => {\n  throw Error(message)\n}\n","//eslint-disable-next-line\nexport * as is from './validate'\nimport {throwError} from './throw'\n\nexport const isObject = (value: any) =>\n  typeof value === 'object' && value !== null\nexport const isFunction = (value: any) => typeof value === 'function'\n\nexport const assertObject = (value: any) => {\n  if (!isObject(value) && !isFunction(value))\n    throwError('expect first argument be an object') // or function\n}\n","const idCount = () => {\n  let id = 0\n  return () => (++id).toString(36)\n}\n\nexport const nextUnitID = idCount()\nexport const nextStepID = idCount()\nexport const nextNodeID = idCount()\n","export const bind = (fn: Function, target: any) => fn.bind(null, target)\nexport const bind2 = (fn: Function, target: any, arg: any) =>\n  fn.bind(null, target, arg)\n","import {StateRef, Run, Filter, Compute, Barrier, Check, Mov} from './index.h'\nimport {nextStepID} from './id'\nimport {bind2} from './bind'\nimport {BARRIER, FILTER, STACK, STORE} from './tag'\n\nconst cmd = (type: any, hasRef: boolean, data: any): any => ({\n  id: nextStepID(),\n  type,\n  data,\n  hasRef,\n})\n\nlet nextBarrierID = 0\n\nexport const barrier: (data: {priority?: 'barrier' | 'sampler'}) => Barrier = ({\n  priority = BARRIER,\n}) =>\n  cmd(BARRIER, false, {\n    barrierID: ++nextBarrierID,\n    priority,\n  })\nexport const mov: (data: {\n  from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  to?: 'stack' | 'a' | 'b'\n  store?: any\n  target?: any\n}) => Mov = ({from = STORE, store, target, to = target ? STORE : STACK}) =>\n  cmd('mov', from === STORE, {from, store, to, target})\nexport const check: {\n  defined(): Check\n  changed(config: {store: StateRef}): Check\n} = {\n  defined: () => cmd('check', false, {type: 'defined'}),\n  changed: ({store}) => cmd('check', true, {type: 'changed', store}),\n}\nexport const compute: (data: {\n  fn: (data: any, scope: {[key: string]: any}, stack: any) => any\n}) => Compute = bind2(cmd, 'compute', false)\nexport const filter: (data: {\n  fn: (data: any, scope: {[key: string]: any}, stack: any) => any\n}) => Filter = bind2(cmd, FILTER, false)\nexport const run: (data: {\n  fn: (data: any, scope: {[key: string]: any}, stack: any) => any\n}) => Run = bind2(cmd, 'run', false)\nexport const update: (data: {store: StateRef}) => Mov = ({store}) =>\n  mov({from: STACK, target: store})\n","import {StateRef} from './index.h'\nimport {nextStepID} from './id'\n\nexport const createStateRef = (current?: any): StateRef => ({\n  id: nextStepID(),\n  current,\n})\nexport const readRef = ({current}: StateRef | {current: any}) => current\n","export const callStackAReg = (stack: any, {fn}: any, {a}: any) => fn(stack, a)\nexport const callARegStack = (stack: any, {fn}: any, {a}: any) => fn(a, stack)\nexport const callStack = (stack: any, {fn}: any, _: any) => fn(stack)\n","import {Graph} from './index.h'\n\nexport const getGraph = (graph: any): Graph => graph.graphite || graph\nexport const getOwners = (node: Graph) => node.family.owners\nexport const getLinks = (node: Graph) => node.family.links\nexport const getStoreState = (store: any) => store.stateRef\nexport const getConfig = (opts: any) => opts.config\nexport const getNestedConfig = (opts: any) => opts.ɔ\nexport const getValue = (stack: any) => stack.value\nexport const getSubscribers = (store: any) => store.subscribers\nexport const getParent = (unit: any) => unit.parent\nexport const getForkPage = (val: any) => val.forkPage\n","import {Graphite} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\nimport {DOMAIN, CROSSLINK} from './tag'\n\nexport const own = (ownerUnit: Graphite, links: Graphite[]) => {\n  const owner = getGraph(ownerUnit)\n  for (let i = 0; i < links.length; i++) {\n    const link = getGraph(links[i])\n    if (owner.family.type !== DOMAIN) link.family.type = CROSSLINK\n    getOwners(link).push(owner)\n    getLinks(owner).push(link)\n  }\n}\n","import {Graph} from './index.h'\nimport {readRef} from './stateRef'\nimport {getForkPage, getGraph, getValue} from './getter'\nimport {\n  STORE,\n  EFFECT,\n  SAMPLER,\n  STACK,\n  BARRIER,\n  VALUE,\n  FILTER,\n  REG_A,\n} from './tag'\n\n/** Names of priority groups */\ntype PriorityTag = 'child' | 'pure' | 'barrier' | 'sampler' | 'effect'\n\n/**\n * Position in the current branch,\n * including call stack, priority type\n * and index of next step in the executed Graph\n */\ntype Layer = {\n  idx: number\n  stack: Stack\n  type: PriorityTag\n  id: number\n}\n\n/** Call stack */\ntype Stack = {\n  value: any\n  a: any\n  b: any\n  parent: Stack | null\n  node: Graph\n  page: {[id: string]: any} | null\n  forkPage?: any\n}\n\n/** Queue as linked list or skew heap */\ntype QueueItem = {\n  /** node value */\n  v: Layer\n  /** left node. always null in queue but used in skew heap */\n  l: QueueItem | null\n  /** right node */\n  r: QueueItem | null\n}\ntype QueueBucket = {\n  first: QueueItem | null\n  last: QueueItem | null\n  size: number\n}\n\n/** Dedicated local metadata */\ntype Local = {\n  fail: boolean\n  scope: {[key: string]: any}\n}\n\nlet heap: QueueItem | null = null\n\nconst merge = (a: QueueItem | null, b: QueueItem | null): QueueItem | null => {\n  if (!a) return b\n  if (!b) return a\n\n  let ret\n  const isSameType = a.v.type === b.v.type\n  if (\n    /**\n     * if both nodes has the same PriorityType\n     * and first node is created after second one\n     */\n    (isSameType && a.v.id > b.v.id) ||\n    /** if first node is \"sampler\" and second node is \"barrier\" */\n    (!isSameType && a.v.type === SAMPLER)\n  ) {\n    ret = a\n    a = b\n    b = ret\n  }\n  ret = merge(a.r, b)\n  a.r = a.l\n  a.l = ret\n\n  return a\n}\n\n/** queue buckets for each PriorityType */\nconst queue: QueueBucket[] = []\nlet ix = 0\nwhile (ix < 5) {\n  /**\n   * although \"sampler\" and \"barrier\" are using heap instead of linked list,\n   * their buckets are still useful: they maintains size of heap queue\n   */\n  queue.push({first: null, last: null, size: 0})\n  ix += 1\n}\n\nconst deleteMin = () => {\n  for (let i = 0; i < 5; i++) {\n    const list = queue[i]\n    if (list.size > 0) {\n      /**\n       * second bucket is for \"barrier\" PriorityType (used in combine)\n       * and third bucket is for \"sampler\" PriorityType (used in sample and guard)\n       */\n      if (i === 2 || i === 3) {\n        list.size -= 1\n        const value = heap!.v\n        heap = merge(heap!.l, heap!.r)\n        return value\n      }\n      if (list.size === 1) {\n        list.last = null\n      }\n      const item = list.first\n      list.first = item!.r\n      list.size -= 1\n      return item!.v\n    }\n  }\n}\nconst pushFirstHeapItem = (\n  type: PriorityTag,\n  page: {[id: string]: any} | null,\n  node: Graph,\n  parent: Stack | null,\n  value: any,\n  forkPage: any | void,\n) =>\n  pushHeap(\n    0,\n    {\n      a: null,\n      b: null,\n      node,\n      parent,\n      value,\n      page,\n      forkPage,\n    },\n    type,\n  )\nconst pushHeap = (idx: number, stack: Stack, type: PriorityTag, id = 0) => {\n  const priority = getPriority(type)\n  const bucket: QueueBucket = queue[priority]\n  const item: QueueItem = {\n    v: {\n      idx,\n      stack,\n      type,\n      id,\n    },\n    //@ts-ignore\n    l: 0,\n    //@ts-ignore\n    r: 0,\n  }\n  /**\n   * second bucket is for \"barrier\" PriorityType (used in combine)\n   * and third bucket is for \"sampler\" PriorityType (used in sample and guard)\n   */\n  if (priority === 2 || priority === 3) {\n    heap = merge(heap, item)\n  } else {\n    if (bucket.size === 0) {\n      bucket.first = item\n    } else {\n      bucket.last!.r = item\n    }\n    bucket.last = item\n  }\n  bucket.size += 1\n}\n\nconst getPriority = (t: PriorityTag) => {\n  switch (t) {\n    case 'child':\n      return 0\n    case 'pure':\n      return 1\n    case BARRIER:\n      return 2\n    case SAMPLER:\n      return 3\n    case EFFECT:\n      return 4\n    default:\n      return -1\n  }\n}\n\nconst barriers = new Set()\n\nlet isRoot = true\nexport let isWatch = false\nexport let currentPage: any = null\nexport let forkPage: any\nexport const setForkPage = (newForkPage: any) => {\n  forkPage = newForkPage\n}\nexport const setCurrentPage = (newPage: any) => {\n  currentPage = newPage\n}\n\n/** main execution method */\nconst exec = () => {\n  const lastStartedState = {isRoot, currentPage, forkPage, isWatch}\n  isRoot = false\n  let stop\n  let skip\n  let graph\n  let value\n  let page\n  let reg\n  mem: while ((value = deleteMin())) {\n    const {idx, stack, type} = value\n    graph = stack.node\n    currentPage = page = stack.page\n    forkPage = getForkPage(stack)\n    reg = (page ? page : graph).reg\n    const local: Local = {\n      fail: false,\n      scope: graph.scope,\n    }\n    stop = skip = false\n    for (let stepn = idx; stepn < graph.seq.length && !stop; stepn++) {\n      const step = graph.seq[stepn]\n      const data = step.data\n      switch (step.type) {\n        case BARRIER: {\n          let id = data.barrierID\n          if (page) {\n            id = `${page.fullID}_${id}`\n          }\n          const priority = data.priority\n          if (stepn !== idx || type !== priority) {\n            if (!barriers.has(id)) {\n              barriers.add(id)\n              pushHeap(stepn, stack, priority, id)\n            }\n            continue mem\n          }\n          barriers.delete(id)\n          break\n        }\n        case 'mov': {\n          let value\n          //prettier-ignore\n          switch (data.from) {\n            case STACK: value = getValue(stack); break\n            case REG_A: /** fall-through case */\n            case 'b':\n              value = stack[data.from]\n              break\n            case VALUE: value = data.store; break\n            case STORE:\n              if (!reg[data.store.id]) {\n                // if (!page.parent) {\n                stack.page = page = null\n                reg = graph.reg\n                // }\n              }\n              value = readRef(reg[data.store.id])\n              break\n          }\n          //prettier-ignore\n          switch (data.to) {\n            case STACK: stack.value = value; break\n            case REG_A: /** fall-through case */\n            case 'b':\n              stack[data.to] = value\n              break\n            case STORE:\n              reg[data.target.id].current = value\n              break\n          }\n          break\n        }\n        case 'check':\n          switch (data.type) {\n            case 'defined':\n              skip = getValue(stack) === undefined\n              break\n            case 'changed':\n              skip = getValue(stack) === readRef(reg[data.store.id])\n              break\n          }\n          break\n        case FILTER:\n          /**\n           * handled edge case: if step.fn will throw,\n           * tryRun will return null\n           * thereby forcing that branch to stop\n           */\n          skip = !tryRun(local, data, stack)\n          break\n        case 'run':\n          /** exec 'compute' step when stepn === idx */\n          if (stepn !== idx || type !== EFFECT) {\n            pushHeap(stepn, stack, EFFECT)\n            continue mem\n          }\n        case 'compute':\n          isWatch = graph.meta.op === 'watch'\n          stack.value = tryRun(local, data, stack)\n          isWatch = lastStartedState.isWatch\n          break\n      }\n      stop = local.fail || skip\n    }\n    if (!stop) {\n      for (let stepn = 0; stepn < graph.next.length; stepn++) {\n        pushFirstHeapItem(\n          'child',\n          page,\n          graph.next[stepn],\n          stack,\n          getValue(stack),\n          getForkPage(stack),\n        )\n      }\n    }\n  }\n  isRoot = lastStartedState.isRoot\n  currentPage = lastStartedState.currentPage\n  forkPage = getForkPage(lastStartedState)\n}\nexport const launch = (unit: any, payload?: any, upsert?: boolean) => {\n  let page = currentPage\n  let stack = null\n  let forkedPage = forkPage\n  if (unit.target) {\n    payload = unit.params\n    upsert = unit.defer\n    page = 'page' in unit ? unit.page : page\n    if (unit[STACK]) stack = unit[STACK]\n    forkedPage = getForkPage(unit) || forkedPage\n    unit = unit.target\n  }\n  if (Array.isArray(unit)) {\n    for (let i = 0; i < unit.length; i++) {\n      pushFirstHeapItem(\n        'pure',\n        page,\n        getGraph(unit[i]),\n        stack,\n        payload[i],\n        forkedPage,\n      )\n    }\n  } else {\n    pushFirstHeapItem('pure', page, getGraph(unit), stack, payload, forkedPage)\n  }\n  if (upsert && !isRoot) return\n  exec()\n}\n\n/** try catch for external functions */\nconst tryRun = (local: Local, {fn}: any, stack: Stack) => {\n  try {\n    return fn(getValue(stack), local.scope, stack)\n  } catch (err) {\n    console.error(err)\n    local.fail = true\n  }\n}\n","import {getConfig, getNestedConfig} from './getter'\nimport {assertObject} from './is'\n\nexport const onConfigNesting = (\n  rawConfig: any,\n  fn: (babelData: any, userConfig: any) => void,\n) => {\n  assertObject(rawConfig)\n  if (getNestedConfig(rawConfig)) {\n    fn(getConfig(rawConfig), getNestedConfig(rawConfig))\n  }\n}\n\nexport const processArgsToConfig = (args: any[]): [any[], any | void] => {\n  let metadata\n  onConfigNesting(args[0], (injected, config) => {\n    metadata = injected\n    args = config\n  })\n  return [args, metadata]\n}\n","import {Graph, Graphite} from './index.h'\nimport {getGraph, getOwners, getLinks, getSubscribers} from './getter'\nimport {is} from './is'\nimport {removeItem} from './collection'\nimport {CROSSLINK} from './tag'\n\nconst removeFromNode = (currentNode: Graph, targetNode: Graph) => {\n  removeItem(currentNode.next, targetNode)\n  removeItem(getOwners(currentNode), targetNode)\n  removeItem(getLinks(currentNode), targetNode)\n}\nconst clearNodeNormalized = (\n  targetNode: Graph,\n  deep: boolean,\n  isDomainUnit: boolean,\n) => {\n  targetNode.next.length = 0\n  targetNode.seq.length = 0\n  //@ts-ignore\n  targetNode.scope = null\n  let currentNode\n  let list = getLinks(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (\n      deep ||\n      (isDomainUnit && !targetNode.meta.sample) ||\n      currentNode.family.type === CROSSLINK\n    ) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        currentNode.meta.op !== 'on' && isDomainUnit,\n      )\n    }\n  }\n  list = getOwners(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (isDomainUnit && currentNode.family.type === CROSSLINK) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        currentNode.meta.op !== 'on' && isDomainUnit,\n      )\n    }\n  }\n}\nconst clearMap = (map: any) => map.clear()\nexport const clearNode = (\n  graphite: Graphite,\n  {\n    deep,\n  }: {\n    deep?: boolean\n  } = {},\n) => {\n  let isDomainUnit = false\n  //@ts-ignore\n  if (graphite.ownerSet) graphite.ownerSet.delete(graphite)\n  if (is.store(graphite)) {\n    clearMap(getSubscribers(graphite))\n  } else if (is.domain(graphite)) {\n    isDomainUnit = true\n    //@ts-ignore\n    const history = graphite.history\n    clearMap(history.events)\n    clearMap(history.effects)\n    clearMap(history.stores)\n    clearMap(history.domains)\n  }\n  clearNodeNormalized(getGraph(graphite), !!deep, isDomainUnit)\n}\n","import {Subscription, Graphite} from './index.h'\nimport {bind2} from './bind'\nimport {clearNode} from './clearNode'\n\nexport const createSubscription = (node: Graphite): Subscription => {\n  const result = bind2(clearNode, node, undefined)\n  result.unsubscribe = result\n  return result\n}\n","import {onConfigNesting} from './config'\nimport {createNode} from './createNode'\nimport {Subscription, Graphite, Cmd} from './index.h'\nimport {createSubscription} from './subscription'\nimport {throwError} from './throw'\nimport {addToRegion} from './region'\n\nexport const createLinkNode = (\n  parent: Graphite,\n  child: Graphite,\n  {\n    node,\n    scope,\n    meta,\n  }: {\n    node?: Array<Cmd | false | void | null>\n    scope?: {[name: string]: any}\n    meta?: {[name: string]: any}\n  },\n) =>\n  addToRegion(\n    createNode({\n      node,\n      parent,\n      child,\n      scope,\n      meta,\n      family: {\n        owners: [parent, child],\n        links: child,\n      },\n    }),\n  )\nexport const forward = (opts: {\n  from: Graphite | Graphite[]\n  to: Graphite | Graphite[]\n  meta?: Record<string, any>\n}): Subscription => {\n  let config\n  onConfigNesting(opts, (injectedData, userConfig) => {\n    config = injectedData\n    opts = userConfig\n  })\n  const {from, to, meta = {op: 'forward'}} = opts\n  if (!from || !to) throwError('from and to fields should be defined')\n  if (config) meta.config = config\n  return createSubscription(\n    addToRegion(\n      createNode({\n        parent: from,\n        child: to,\n        meta,\n        family: {},\n      }),\n    ),\n  )\n}\n","import {step} from './typedef'\nimport {callStack} from './caller'\nimport {createNode} from './createNode'\nimport {Subscription, Unit} from './index.h'\nimport {createSubscription} from './subscription'\nimport {addToRegion} from './region'\nimport {throwError} from './throw'\nimport {isFunction} from './is'\nimport {forkPage} from './kernel'\nimport {getGraph} from './getter'\n\nexport const watchUnit = (\n  unit: Unit,\n  handler: (payload: any) => any,\n): Subscription => {\n  if (!isFunction(handler)) throwError('.watch argument should be a function')\n  if (forkPage) {\n    const forkedNode = forkPage.nodeMap[getGraph(unit).id]\n    if (forkedNode) unit = forkedNode\n  }\n  return createSubscription(\n    addToRegion(\n      createNode({\n        scope: {fn: handler},\n        node: [step.run({fn: callStack})],\n        parent: unit,\n        meta: {op: 'watch'},\n        family: {\n          owners: unit,\n        },\n      }),\n    ),\n  )\n}\n","import {Store, Event, Effect, Domain} from './unit.h'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {Config} from './index.h'\nimport {\n  createEvent,\n  createStore,\n  createNamedEvent,\n  initUnit,\n} from './createUnit'\nimport {createEffect} from './createEffect'\nimport {forward} from './forward'\nimport {addToRegion} from './region'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\nimport {DOMAIN} from './tag'\n\nconst createHook = (trigger: Event<any>, acc: Set<any>, node: any) => {\n  trigger.watch(data => {\n    own(node, [data])\n    acc.add(data)\n    if (!data.ownerSet) data.ownerSet = acc\n    if (!getParent(data)) data.parent = node\n  })\n  own(node, [trigger])\n  return (hook: (data: any) => any) => {\n    acc.forEach(hook)\n    return trigger.watch(hook)\n  }\n}\n\nexport function createDomain(nameOrConfig: any, maybeConfig?: any): Domain {\n  const domains: Set<Domain> = new Set()\n  const stores: Set<Store<any>> = new Set()\n  const effects: Set<Effect<any, any, any>> = new Set()\n  const events: Set<Event<any>> = new Set()\n\n  const node = createNode({\n    family: {type: DOMAIN},\n  })\n\n  const result: any = {\n    history: {\n      domains,\n      stores,\n      effects,\n      events,\n    },\n    graphite: node,\n  }\n\n  node.meta = initUnit(DOMAIN, result, maybeConfig, nameOrConfig)\n  const [event, effect, store, domain] = [\n    'onEvent',\n    'onEffect',\n    'onStore',\n    'onDomain',\n  ].map(createNamedEvent)\n\n  result.hooks = {\n    event,\n    effect,\n    store,\n    domain,\n  }\n  result.onCreateEvent = createHook(event, events, result)\n  result.onCreateEffect = createHook(effect, effects, result)\n  result.onCreateStore = createHook(store, stores, result)\n  result.onCreateDomain = createHook(domain, domains, result)\n\n  result.createEvent = result.event = (nameOrConfig: any, config?: Config) =>\n    event(\n      createEvent(nameOrConfig, {\n        parent: result,\n        config,\n      }),\n    )\n  result.createEffect = result.effect = (nameOrConfig: any, config?: Config) =>\n    effect(\n      createEffect(nameOrConfig, {\n        parent: result,\n        config,\n      }),\n    )\n  result.createDomain = result.domain = (nameOrConfig: any, config?: Config) =>\n    createDomain({\n      name: nameOrConfig,\n      parent: result,\n      config,\n    })\n  result.createStore = result.store = (state: any, config?: Config) =>\n    store(\n      createStore(state, {\n        parent: result,\n        config,\n      }),\n    )\n  addToRegion(result)\n  const parent = getParent(result)\n  if (parent) {\n    forIn(result.hooks, (from, key) => {\n      forward({from, to: parent.hooks[key]})\n    })\n    parent.hooks.domain(result)\n  }\n  return result\n}\n","import {combine} from './combine'\nimport {createEffect, onSettled} from './createEffect'\nimport {applyParentHook} from './createUnit'\nimport {onConfigNesting} from './config'\nimport {getGraph, getStoreState} from './getter'\nimport {own} from './own'\nimport {is} from './is'\nimport {step} from './typedef'\nimport {launch} from './kernel'\nimport {addToReg} from './createNode'\nimport {STORE, EFFECT, REG_A} from './tag'\n\nexport function attach(config: any) {\n  let injected\n  onConfigNesting(config, (injectedData, userConfig) => {\n    injected = injectedData\n    config = userConfig\n  })\n  let {source, effect, mapParams} = config\n  if (!mapParams)\n    mapParams = source\n      ? (_: any, source: any) => source\n      : (params: any) => params\n  const attached = createEffect(config, injected)\n  const {runner} = getGraph(attached).scope\n\n  let runnerSteps\n  const runnerFn = (\n    {params, req}: any,\n    {finally: anyway, effect}: any,\n    stack: any,\n  ) => {\n    const rj = onSettled({\n      params,\n      req,\n      ok: false,\n      anyway,\n      stack,\n    })\n    let computedParams\n    try {\n      computedParams = mapParams(params, stack.a)\n    } catch (err) {\n      return rj(err)\n    }\n    launch({\n      target: effect,\n      params: {\n        params: computedParams,\n        req: {\n          rs: onSettled({\n            params,\n            req,\n            ok: true,\n            anyway,\n            stack,\n          }),\n          rj,\n        },\n      },\n      page: stack.page,\n      defer: true,\n    })\n  }\n  if (source) {\n    let state\n    if (is.store(source)) state = source\n    else {\n      state = combine(source)\n      own(attached, [state])\n    }\n    const readStateRef = step.mov({\n      from: STORE,\n      store: getStoreState(state),\n      to: REG_A,\n    })\n    runnerSteps = [\n      /* let another side-effects run first */\n      step.run({fn: _ => _}),\n      /* read state. assumed it already stable here because of previous step */\n      readStateRef,\n      /* no need for step.run because of first step */\n      step.compute({fn: runnerFn}),\n    ]\n    addToReg(readStateRef, runner.reg)\n  } else {\n    runnerSteps = [step.run({fn: runnerFn})]\n  }\n  runner.scope.effect = effect\n  runner.meta.onCopy.push(EFFECT)\n  runner.seq.splice(0, 1, ...runnerSteps)\n  applyParentHook(effect, attached, EFFECT)\n  return attached\n}\n","import {Store, Event} from './unit.h'\nimport {createEvent, applyParentHook} from './createUnit'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\nimport {processArgsToConfig} from './config'\n\nexport function createApi(...args: [Store<any>, {[key: string]: Function}]) {\n  let [[store, setters], metadata] = processArgsToConfig(args)\n  const result: Record<string, Event<any>> = {}\n  forIn(setters, (fn, key) => {\n    const event = (result[key] = createEvent(key, {\n      parent: getParent(store),\n      config: metadata,\n    }))\n    store.on(event, fn)\n    applyParentHook(store, event)\n  })\n  return result\n}\n","import {observableSymbol} from './observable'\nimport {Event} from './unit.h'\nimport {clearNode} from './clearNode'\nimport {createEvent} from './createUnit'\nimport {bind2} from './bind'\nimport {assertObject} from './is'\nimport {throwError} from './throw'\n\nexport function fromObservable<T>(observable: any): Event<T> {\n  assertObject(observable)\n  const observableItem =\n    observableSymbol in observable ? observable[observableSymbol]() : observable\n  if (!observableItem.subscribe)\n    throwError('expect observable to have .subscribe')\n  const event = createEvent<T>()\n  const disposer = bind2(clearNode, event, undefined)\n  observableItem.subscribe({\n    next: event,\n    error: disposer,\n    complete: disposer,\n  })\n  return event\n}\n","import {processArgsToConfig} from './config'\nimport {createLinkNode} from './forward'\nimport {sample} from './sample'\nimport {createEvent} from './createUnit'\nimport {combine} from './combine'\nimport {step} from './typedef'\nimport {callStack} from './caller'\nimport {is, isFunction} from './is'\nimport {createNode} from './createNode'\nimport {addToRegion} from './region'\nimport {throwError} from './throw'\n\nexport function guard(...args: any[]) {\n  const meta: Record<string, any> = {op: 'guard'}\n  let rawName = 'guard'\n  let [[source, config], metadata] = processArgsToConfig(args)\n  if (metadata) {\n    meta.config = metadata\n    if (metadata.name) rawName = metadata.name\n  }\n  if (!config) {\n    config = source\n    source = config.source\n  }\n  const {filter, greedy, name = rawName} = config\n  const target = config.target || createEvent(name, meta.config)\n  if (!is.unit(source)) source = combine(source)\n\n  if (is.unit(filter)) {\n    sample({\n      source: filter,\n      clock: source,\n      target: addToRegion(\n        createNode({\n          node: [\n            step.filter({\n              fn: ({guard}) => guard,\n            }),\n            step.compute({\n              fn: ({data}) => data,\n            }),\n          ],\n          child: target,\n          meta,\n          family: {\n            owners: [source, filter, target],\n            links: target,\n          },\n        }),\n      ),\n      fn: (guard: any, data: any) => ({guard, data}),\n      greedy,\n      name,\n    })\n  } else {\n    if (!isFunction(filter)) throwError('`filter` should be function or unit')\n    createLinkNode(source, target, {\n      scope: {fn: filter},\n      node: [step.filter({fn: callStack})],\n      meta,\n    })\n  }\n  return target\n}\n","import {Store, Event, Effect} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {forward} from './forward'\nimport {unitObjectName} from './naming'\n\nexport function merge<T>(\n  events: Array<Event<T> | Store<T> | Effect<T, any, any>>,\n  config?: object,\n): Event<T> {\n  const result = createEvent(config || unitObjectName(events, 'merge'))\n  forward({\n    from: events,\n    to: result,\n    meta: {op: 'merge'},\n  })\n  return result\n}\n","import {createStore} from './createUnit'\nimport {is} from './is'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\n\nexport function restore(obj: any, defaultState: any, config?: any): any {\n  if (is.store(obj)) {\n    return obj\n  }\n  if (is.unit(obj)) {\n    const domain = getParent(obj)\n    let result\n    if (is.event(obj)) {\n      result = createStore(defaultState, {\n        parent: domain,\n        name: obj.shortName,\n        ɔ: config,\n      }).on(obj, (_, v) => v)\n    }\n    if (is.effect(obj)) {\n      result = createStore(defaultState, {\n        parent: domain,\n        name: obj.shortName,\n        ɔ: config,\n      }).on(obj.done, (_: any, {result}: any) => result)\n    }\n    if (domain) domain.hooks.store(result)\n    return result\n  }\n  const result: Record<string, any> = Array.isArray(obj) ? [] : {}\n  forIn(obj, (value, key) => {\n    result[key] = is.store(value) ? value : createStore(value, {name: key})\n  })\n  return result\n}\n","import {Event} from './unit.h'\nimport {is} from './is'\nimport {forIn} from './collection'\nimport {forward} from './forward'\nimport {processArgsToConfig} from './config'\n\nexport function split(...args: any[]): any {\n  let cases: any\n  let [[unit, match], metadata] = processArgsToConfig(args)\n  const knownCases = !match\n  if (knownCases) {\n    cases = unit.cases\n    match = unit.match\n    unit = unit.source\n  }\n  const result = {} as Record<string, Event<any>>\n  let current: Event<any> = is.store(unit) ? unit.updates : unit\n  forIn(match, (fn, key) => {\n    //@ts-ignore\n    result[key] = current.filter({fn, config: metadata})\n    //@ts-ignore\n    current = current.filter({\n      fn: data => !fn(data),\n      config: metadata,\n    })\n  })\n  result.__ = current\n  if (knownCases) {\n    forIn(result, (event, key) => {\n      if (cases[key]) {\n        forward({\n          from: event,\n          to: cases[key],\n        })\n      }\n    })\n  } else return result\n}\n"],"names":["createNode","node","from","source","parent","to","target","child","scope","meta","family","familyRaw","type","sources","arrifyNodes","links","owners","seq","reg","i","length","item","push","addToReg","result","id","nextNodeID","next","CROSSLINK","getOwners","getLinks","unitObjectName","objOrArr","method","name","comma","key","unit","is","compositeName","fullName","toString","createName","path","composite","shortName","concat","forEach","list","fn","withRegion","cb","unitMeta","getGraph","regionStack","value","template","readTemplate","sidRoot","getParent","createEvent","nameOrConfig","maybeConfig","event","payload","args","currentPage","oldPage","page","setCurrentPage","create","callCreate","graphite","initUnit","EVENT","forkPage","find","launch","watch","bind","watchUnit","map","config","isObject","mapped","mapName","createComputation","MAP","filter","createEventFiltration","FILTER","step","callStack","filterMap","defined","prepend","contramapped","upward","applyParentHook","addToRegion","createStore","defaultState","props","onEvent","store","off","getSubscribers","set","createSubscription","updateStore","plainState","createStateRef","oldState","updates","createNamedEvent","after","plain","plainStateId","subscribers","Map","stateRef","getState","reachedPage","targetRef","readRef","setState","state","nodeMap","params","defer","reset","units","on","events","Array","isArray","currentSubscription","get","delete","firstState","lastResult","storeState","undefined","innerStore","strict","linkNode","getStoreState","before","includes","loader","unshift","eventOrFn","subscription","of","isFunction","throwError","changed","STORE","isStrict","own","combine","handler","stores","onConfigNesting","injectedData","userConfig","structStoreShape","shapeReady","rawHandler","slice","obj","spreadArgs","storeCombination","createDefer","req","Promise","rs","rj","catch","err","createEffect","instance","defaultConfig","getType","onCopy","kind","EFFECT","use","anyway","finally","done","named","status","fail","error","doneData","failData","effectRunner","getHandler","getCurrent","stack","onResolve","onSettled","ok","onReject","then","op","fx","runner","data","upd","getForkPage","isWatch","savedFork","setForkPage","inFlight","x","pending","amount","sample","sid","greedy","clock","metadata","processArgsToConfig","isUpward","targetTemplate","nativeTemplate","sourceRef","createLinkNode","priority","SAMPLER","REG_A","STACK","callARegStack","SAMPLE","closure","hasSource","sourceState","clockState","VALUE","callStackAReg","createRefGraph","refsMap","items","Object","values","refGraph","cmd","normalizeValues","toposort","rawGraph","ignore","topologicalSortHelper","temp","neighbors","graph","n","visited","Set","reverse","size","processed","ignored","shift","removeItem","flatGraph","traverse","forEachRelatedNode","FORK_COUNTER","observableSymbol","Symbol","observable","DOMAIN","BARRIER","effect","domain","message","Error","assertObject","idCount","nextUnitID","nextStepID","bind2","arg","hasRef","nextBarrierID","barrier","barrierID","mov","check","compute","run","update","current","a","getConfig","opts","getNestedConfig","ɔ","getValue","val","ownerUnit","owner","link","heap","merge","b","ret","isSameType","v","r","l","queue","ix","first","last","deleteMin","pushFirstHeapItem","pushHeap","idx","getPriority","bucket","t","barriers","isRoot","newForkPage","newPage","upsert","forkedPage","stop","skip","lastStartedState","mem","local","stepn","fullID","has","add","tryRun","exec","console","joinName","tag","rawConfig","injected","forIn","pos","indexOf","splice","removeFromNode","currentNode","targetNode","clearNodeNormalized","deep","isDomainUnit","pop","clearMap","clear","clearNode","ownerSet","history","effects","domains","unsubscribe","readSidRoot","forward","forkedNode","normalizeConfig","part","loc","hookType","hooks","rawConfigA","rawConfigB","isDomain","unitId","thru","subscribe","observer","stateFirst","storeRef","ref","clone","stateNew","rawShape","isFresh","childRef","field","defaultShape","sidechain","createHook","trigger","acc","hook","start","ctx","reject","parentFork","forkInFlightCounter","defers","launchUnits","launchParams","mapParams","_","runnerSteps","attached","runnerFn","computedParams","readStateRef","setters","createDomain","onCreateEvent","onCreateEffect","onCreateStore","onCreateDomain","handlers","needToFill","forked","findClone","index","unitName","clones","refs","forkPageSetter","fxID","resolve","sidMap","forkOf","newRef","j","siblings","wrapped","wrapStore","cloneOf","cloneGraph","sourceList","sourceRefsMap","predefinedRefs","templateOwnedRefs","valuesSidList","getOwnPropertyNames","execRef","fillValues","handlerKeys","keys","observableItem","disposer","complete","rawName","guard","isScope","storeWatches","storeWatchesRefs","normalizedValues","fillResult","flatGraphUnits","collectWatches","savedStack","onlyChanges","currentComposite","cases","match","knownCases","__"],"mappings":"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"}