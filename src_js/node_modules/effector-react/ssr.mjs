function e(e){g.store(e)||j('expect useStore argument to be a store');let t=k.useRef(e),r=k.useState(e.getState())[1];return w((()=>(t.current===e&&r(e.getState()),t.current=e,e.updates.watch(r))),[e]),e.getState()}function t({store:t,keys:r,fn:n}){g.store(t)||j('useStoreMap expects a store'),Array.isArray(r)||j('useStoreMap expects an array as keys'),'function'!=typeof n&&j('useStoreMap expects a function');let o=k.useMemo((()=>h(n(t.getState(),r)).on(t,((e,t)=>n(t,r)))),r),s=e(o);return w((()=>()=>{o.off(t),x(o,{deep:1})}),r),s}function r(e,t){return t.displayName=e,t}function n(e){let t=k.useContext(M);if(!t)throw Error('No scope found, consider adding <Provider> to app root');return t.find(e).meta.wrapped}function o(e){if(!e||!g.domain(e.domain))throw Error('config.domain should exists');return(({name:e="gate",domain:t,defaultState:n,hook:o})=>{function s(e){return o(s,e),null}let u=S(),a=S(),f=S(),i=h(Boolean(0),{named:'status'}).on(a,(()=>Boolean(1))).on(f,(()=>Boolean(0))),c=h(n,{named:'state'}).on(u,((e,t)=>t)).reset(f);if(t){let{hooks:e}=t;b({target:[e.store,e.store,e.event,e.event,e.event],params:[i,c,a,f,u]})}return s.open=a,s.close=f,s.status=i,s.state=c,s.set=u,r("Gate:"+e,s)})({domain:e.domain,name:e.name,defaultState:'defaultState'in e?e.defaultState:{},hook:s})}function s(e,t={}){let r=y(e.open),n=y(e.close),o=y(e.set);((e,t={})=>{let r=k.useRef(null);w((()=>(e.open(r.current),()=>e.close(r.current))),[e]),((e,t)=>{if(e===t)return 1;if('object'==typeof e&&null!==e&&'object'==typeof t&&null!==t){let r=Object.keys(e),n=Object.keys(t);if(r.length!==n.length)return 0;for(let n=0;n<r.length;n++){let o=r[n];if(e[o]!==t[o])return 0}return 1}return 0})(r.current,t)||(r.current=t,e.set(t))})(k.useMemo((()=>({open:r,close:n,set:o})),[e,r]),t)}function u(e){return t=>{let r=l(e);return t.children(r)}}function a(e,t,r){return n=>{let o=k.useContext(t),s=l(e);return r(n,s,o)}}function f(){throw new Error('not implemented')}function i(e,t){return r(`Connect(${t.displayName||t.name||'Unknown'})`,(r=>k.createElement(t,Object.assign({},r,l(e)))))}function c(e){return t=>i(t,e)}function l(t){return e(n(t))}function m(e,o){return((e,n)=>{let o,s=[];'object'==typeof n&&null!==n?(n.keys&&(s=n.keys),o=n.fn):o=n,g.store(e)||j('expect useList first argument to be a store'),'function'!=typeof o&&j("expect useList's renderItem to be a function"),Array.isArray(s)||j("expect useList's keys to be an array");let u=k.useMemo((()=>{let n=r((e.shortName||'Unknown')+".Item",(({index:r,keys:n})=>{let o=t({store:e,keys:[r,...n],fn:(e,t)=>e[t[0]]});return f.current(o,r)}));return k.memo(n)}),[e]),a=t({store:e,keys:[e],fn:e=>e.length}),f=k.useRef(o);f.current=o;let i=k.useMemo((()=>s),s);return Array.from({length:a},((e,t)=>k.createElement(u,{index:t,key:t,keys:i})))})(n(e),o)}function p({store:e,keys:r,fn:o}){return t({store:n(e),keys:r,fn:o})}function d(e,t){let r=t.find(e);return g.effect(e)?e=>{let n=(()=>{let e={};return e.req=new Promise(((t,r)=>{e.rs=t,e.rj=r})),e})();return b({target:r,params:{params:e,req:n},forkPage:t}),n.req}:e=>(b({target:r,params:e,forkPage:t}),e)}function y(e){let t=k.useContext(M),r=g.unit(e)||'object'!=typeof e?{event:e}:e;return k.useMemo((()=>{if(g.unit(e))return d(e,t);let r=Array.isArray(e)?[]:{};for(let n in e)r[n]=d(e[n],t);return r}),[t,...Object.keys(r),...Object.values(r)])}import k from'react';import{is as g,createStore as h,clearNode as x,createEvent as S,launch as b}from'effector/effector.mjs';let w='undefined'!=typeof window?k.useLayoutEffect:k.useEffect,j=e=>{throw Error(e)};const M=k.createContext(null);let{Provider:E}=M;export{E as Provider,c as connect,f as createComponent,a as createContextComponent,o as createGate,i as createReactState,u as createStoreConsumer,y as useEvent,s as useGate,m as useList,l as useStore,p as useStoreMap};
//# sourceMappingURL=ssr.mjs.map
